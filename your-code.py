# -*- coding: utf-8 -*-
"""OpticalDetectorsAssignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YYrjJzEN-BiUZxByFCrV6q1B1MZ0aks0
"""

# HST HR Diagram Assignment for Space Detector Lab
# Disclaimer; a lot of the code here was pasted directly from the Brightspace uploaded Worked Workbook 01 (Cosmic ray removal), Workbook 02 (star finding),and Workbook 03 (photometry + CMD)
# !pip -q install astropy photutils numpy scipy matplotlib tqdm

from pathlib import Path # from Workbook 1, importing packages
import numpy as np
from astropy.io import fits
import matplotlib.pyplot as plt
from pathlib import Path

DATA = Path("data")
OUT  = Path("outputs")
OUT.mkdir(parents=True, exist_ok=True)
F336W = sorted((DATA/"F336W").glob("*_c0m_aligned.fits")) # aligning the FITS Files
F555W = sorted((DATA/"F555W").glob("*_c0m_aligned.fits"))
print("F336W:", len(F336W), "files")
print("F555W:", len(F555W), "files")

print("F336W files:")
for f in F336W:
    print("  ", f)
print("F555W files:")
for f in F555W:
    print("  ", f)

def read_image_any_hdu(path): # from Workbook 01, median combination & cosmic-ray removal
    with fits.open(path) as hdul:
        for hdu in hdul:
            if getattr(hdu, "data", None) is not None:
                return hdu.data.astype(float), hdu.header # needed some help here from AI as I had an error
    raise ValueError("no image data in file")

def median_combine(files, out_fits): # combining the data
    stack = []
    hdr0 = None
    for f in files:
        data, hdr = read_image_any_hdu(f)
        stack.append(data)
        if hdr0 is None:
            hdr0 = hdr
    med = np.nanmedian(np.stack(stack), axis=0)
    fits.writeto(out_fits, med.astype("float32"), hdr0, overwrite=True)
    print("wrote", out_fits)
    return med

img_u = median_combine(F336W, OUT/"combined_F336W.fits")
img_v = median_combine(F555W, OUT/"combined_F555W.fits")

from google.colab import drive
drive.mount('/content/drive')

# plot check from Workbook 01
vmin, vmax = np.percentile(img_v, [1,99])
plt.imshow(img_v, origin='lower', cmap='gray', vmin=vmin, vmax=vmax)
plt.title("Median-combined F555W")
plt.show()

import numpy as np
from scipy import ndimage as ndi
from astropy.stats import sigma_clipped_stats
from astropy.table import Table

def find_local_peaks(data, nsize=10):
    """quick function to find local peaks"""
    local_max = ndi.maximum_filter(data, size=nsize)
    local_max_mask = (local_max == data)# boolean mask where peaks are True
    coordinates = np.argwhere(local_max_mask) # return (y, x) coordinates of peaks
    return coordinates

mean, med, std = sigma_clipped_stats(img_v, sigma=3.0)
work = img_v - med

coords = find_local_peaks(work, nsize=10)  # tweak n size if too dense/sparse

catalog = Table() # y,x to x,y
if len(coords) > 0:
    ys, xs = coords[:,0].astype(float), coords[:,1].astype(float)
    catalog['id'] = np.arange(1, len(xs)+1)
    catalog['x']  = xs
    catalog['y']  = ys
else:
    catalog['id'] = []
    catalog['x']  = []
    catalog['y']  = []

print("star #:", len(catalog))
catalog[:5]

star_catalog_path = OUT/"star_catalog.csv" # save catalog from Workbook 02
catalog.write(star_catalog_path, overwrite=True)
print("saved", star_catalog_path)

# Replacing photometry, I got help from ChatGpt for a bit of this...
import numpy as np
from astropy.stats import sigma_clipped_stats
import ccd_utils as cu

def do_photometry(image, catalog, r_ap=3.0, r_in=5.0, r_out=8.0):
    """Workbook-style photometry using cu.circular_aperture, with robust annulus mask."""
    fluxes = np.zeros(len(catalog), dtype=float)
    ok = np.zeros(len(catalog), dtype=bool)

    for i, (x, y) in enumerate(np.column_stack([catalog['x'], catalog['y']])):
        cut_src, mask_src = cu.circular_aperture(image, center=(y, x), radius=r_ap)
        if cut_src.size == 0 or mask_src.sum() == 0:
            continue
        src_sum = cut_src[mask_src].sum()

        cut_out, _ = cu.circular_aperture(image, center=(y, x), radius=r_out)
        if cut_out.size == 0:
            continue

        oy, ox = cut_out.shape
        yy, xx = np.indices((oy, ox))
        cy, cx = oy // 2, ox // 2
        dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)
        ann_mask = (dist >= r_in) & (dist <= r_out)

        ann_vals = cut_out[ann_mask]
        if ann_vals.size == 0:
            bkg_med = 0.0
        else:
            _, bkg_med, _ = sigma_clipped_stats(ann_vals, sigma=3.0)

        bkg_sum = bkg_med * mask_src.sum()
        flux = src_sum - bkg_sum
        fluxes[i] = flux
        ok[i] = flux > 0  # rejecting negative flux

    return ok, fluxes

ok_v, flux_v = do_photometry(img_v, catalog, r_ap=3.0, r_in=5.0, r_out=8.0) #Re-running with new
print(f"F555W photometry using: {ok_v.sum()} / {len(catalog)}")

try:
    R_AP
except NameError:
    R_AP, R_IN, R_OUT = 3.0, 5.0, 8.0

ok_v, flux_v = do_photometry(img_v, catalog, r_ap=R_AP, r_in=R_IN, r_out=R_OUT)
ok_u, flux_u = do_photometry(img_u, catalog, r_ap=R_AP, r_in=R_IN, r_out=R_OUT)

print(f"V-band kept: {ok_v.sum()} / {len(catalog)}")
print(f"U-band kept: {ok_u.sum()} / {len(catalog)}")

keep   = ok_v & ok_u
cat2   = catalog[keep]
flux_v2 = flux_v[keep]
flux_u2 = flux_u[keep]

def flux_to_magnitude(flux, zeropoint=25.0): # from workbook 03; flux_to_magnitude
    return -2.5 * np.log10(flux) - abs(zeropoint)

mag_V = flux_to_magnitude(flux_v2)
mag_U = flux_to_magnitude(flux_u2)

from astropy.table import Table
mag_tab = Table()
mag_tab['id'] = cat2['id']
mag_tab['x'] = cat2['x']
mag_tab['y'] = cat2['y']
mag_tab['mag_F555W'] = mag_V
mag_tab['mag_F336W'] = mag_U
mag_tab.write(OUT/"mag_catalog.csv", overwrite=True)

import matplotlib.pyplot as plt
from pathlib import Path

color = mag_V - mag_U 
Vmag  = mag_V           

plt.figure(figsize=(5, 6))
plt.scatter(color, Vmag, s=3, color='white', alpha=0.6)
plt.gca().invert_yaxis()  # brighter stars at the top
plt.xlabel("F555W − F336W", fontsize=12)
plt.ylabel("F555W (mag)", fontsize=12)
plt.title("Hertzsprung–Russell (Colour–Magnitude) Diagram", fontsize=13)
plt.tight_layout()

out = Path("outputs/cmd.png")
plt.savefig(out, dpi=200)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from pathlib import Path

color = mag_V - mag_U
Vmag  = mag_V

cmin, cmax = np.percentile(color, [1, 99])
norm = Normalize(vmin=cmin, vmax=cmax)

plt.style.use("dark_background") # I didnt know you could do this, Again AI was my friend I had a much simpler plot and wanted to level up to make it more 'Hertsprung-Russelly'
plt.figure(figsize=(5, 6))

sc = plt.scatter(color, Vmag, c=color, cmap="jet", norm=norm, s=5, alpha=0.9, edgecolors='none')

plt.gca().invert_yaxis()
plt.xlabel("F555W−F336W", fontsize=12, color='white')
plt.ylabel("F555W (magnitude)", fontsize=12, color='white')
plt.title("Hertzsprung–Russell (Colour–Magnitude) Diagram", fontsize=13, color='white')


cb = plt.colorbar(sc) # Add colorbar
cb.set_label("Colour index (F555W−F336W)")

plt.tight_layout()

out = Path("outputs/cmd_colored.png")
plt.savefig(out, dpi=200, facecolor='black')
plt.show()
